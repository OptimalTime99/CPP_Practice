## 문제 1. 플레이어 HP 감소 방식 비교

**핵심 개념:** CallByValue, CallByPointer, CallByReference

### 시나리오

RPG 게임에서 몬스터의 공격이 플레이어 HP를 깎는다.
디자인팀이 “데미지 미리보기 기능”이랑 “실제 데미지 적용”을 둘 다 원한다.

### 요구사항

1. 플레이어 HP를 나타내는 정수형 변수 `playerHP`를 사용한다고 가정한다.
2. 다음 세 가지 함수를 설계하고 구현하는 문제다:

   * **미리보기용**: 실제 HP는 바뀌지 않고, “이 데미지를 맞으면 HP가 얼마가 되는지” 계산만 해서 출력.
   * **포인터 방식 적용**: 포인터 인자를 사용해 실제 HP를 감소시키는 함수.
   * **레퍼런스 방식 적용**: 레퍼런스 인자를 사용해 실제 HP를 감소시키는 함수.
3. `main`에서:

   * 같은 시작 HP로 세 가지 함수를 각각 호출한 뒤
     HP 변화 유무를 비교해서 출력해라.
   * “왜 이 방식에서만 값이 안 바뀌는지 / 바뀌는지”를 코드로 확인할 수 있게 작성해라.

---

## 문제 2. 아이템 수량 교환 함수 설계

**핵심 개념:** CallByPointer / CallByReference, 포인터와 레퍼런스 차이

### 시나리오

인벤토리 칸 두 개에 각각 포션 수량이 들어 있다.
UI 편의 기능으로, 두 칸의 수량을 서로 바꾸는 기능을 추가하려고 한다.

### 요구사항

1. 인벤토리 슬롯의 아이템 수량을 나타내는 `int slotA`, `int slotB`를 사용한다고 가정한다.
2. **두 슬롯의 수량을 서로 교환하는 함수**를:

   * 포인터 버전
   * 레퍼런스 버전
     두 가지 방식으로 각각 설계하라.
3. 두 버전의 함수를 `main`에서 직접 호출해 보고,
   함수 호출 전/후의 수량 변화를 비교 출력하는 코드를 작성하는 것이 목표다.
4. 포인터 버전에서는 “주소 연산자 &”와 “역참조 *” 사용을 명확히 드러내라.

---

## 문제 3. 탄환 속도/위치 업데이트 함수

**핵심 개념:** 구조체, CallByReference

### 시나리오

슈팅 게임에서 탄환(bullet)은 `위치`와 `속도` 정보를 가진다.
매 프레임마다 속도에 따라 위치를 갱신해야 한다.

### 요구사항

1. 2D 벡터를 나타내는 구조체 `Vector2` 를 정의하라. (예: `x`, `y`)
2. 탄환 한 발을 나타내는 구조체 `Bullet` 을 설계하라.

   * 멤버로 `position`(Vector2), `velocity`(Vector2)를 포함한다.
3. 프레임 시간 `deltaTime`을 받아,

   * `Bullet`의 `position`을 `velocity * deltaTime` 만큼 이동시키는 함수를
     **레퍼런스로 인자를 받아** 구현하는 것이 문제의 핵심이다.
4. `main`에서:

   * 하나의 Bullet을 생성하고 초기 위치/속도를 지정한 뒤,
   * 업데이트 함수를 여러 번 호출하여 위치 변화가 잘 적용되는지 확인하는 흐름을 만들라.

---

## 문제 4. 몬스터 스탯 계산 – CallByValue vs CallByReference

**핵심 개념:** 구조체, CallByValue, CallByReference

### 시나리오

몬스터 스탯을 `HP`, `공격력`, `방어력`으로 관리한다.
밸런싱 작업을 위해 “시뮬레이션 계산용 함수”와 “실제 스탯 변경용 함수”가 필요하다.

### 요구사항

1. `MonsterStats` 구조체를 정의하라.

   * `hp`, `attack`, `defense` 멤버를 가진다.
2. 다음 두 종류의 함수를 설계한다:

   * **시뮬레이션용 함수**: `MonsterStats`를 값으로(CallByValue) 받아,
     내부에서 여러 연산(버프 적용 등)을 하고 결과를 리턴 or 출력하지만,
     **원본 스탯은 절대 바꾸지 않는** 함수.
   * **실제 적용용 함수**: `MonsterStats`를 레퍼런스로 받아,
     버프 또는 디버프를 **실제로 원본에 반영하는** 함수.
3. `main`에서 같은 몬스터 스탯을 가지고 두 함수를 각각 호출해 보고,
   원본이 바뀌는 경우와 안 바뀌는 경우를 비교해 확인하는 흐름을 만들라.

---

## 문제 5. 타일 맵 편집 – 배열 포인터 활용

**핵심 개념:** 2차원 배열, 배열 포인터(pointer to array)

### 시나리오

타일 기반 2D 맵이 있고, 맵은 정수형 2차원 배열로 관리된다.
디자이너가 특정 행(row)의 타일들을 한 번에 편집할 수 있는 API를 원한다.

### 요구사항

1. 타일 맵을 `const int ROWS`, `const int COLS`를 사용한
   `int map[ROWS][COLS];` 형태라고 가정한다.
2. **특정 한 행 전체를 편집하는 함수**를 설계하라.

   * 이 함수는 “배열 포인터”를 이용해 해당 행에 접근해야 한다
     (예: `int (*row)[COLS]` 혹은 적절한 형태).
   * 전달받은 행의 모든 타일 값을 특정 값으로 설정하거나,
     혹은 규칙에 따라 변경하도록 설계해라.
3. `main`에서:

   * 맵을 적당히 초기화한 후,
   * 특정 행만 골라서 편집 함수에 넘기고,
   * 편집 전/후를 출력해 차이를 볼 수 있는 흐름을 만들라.

---

## 문제 6. 적(Enemy) 풀링 시스템 – 포인터 배열 사용

**핵심 개념:** 포인터 배열(array of pointers), 동적 할당, CallByPointer/Reference 응용

### 시나리오

런타임 중에 적을 계속 new/delete 하는 대신,
미리 만들어 둔 Enemy 객체들을 재사용하는 **풀링(Pooling)** 시스템을 만든다.

### 요구사항

1. 간단한 `Enemy` 클래스를 설계하라.

   * 예: `hp`, `isActive` 멤버, `Spawn()`, `Despawn()`, `Update()` 같은 기본 메서드.
2. 고정 크기 풀을 `Enemy* enemyPool[POOL_SIZE];` 형태의 **포인터 배열**로 관리하라.
3. 다음 기능을 구현하도록 설계한다:

   * 초기화 시: 배열의 각 원소에 `new Enemy`를 할당.
   * `SpawnEnemy()`:

     * 비활성(`isActive == false`)인 Enemy를 하나 찾아 활성화시키고,
     * 위치나 HP 초기화 등 기본 세팅을 한다.
   * `UpdateAllEnemies()`:

     * 배열을 순회하며 `isActive == true`인 Enemy만 `Update()` 호출.
   * `DespawnEnemy()`:

     * 특정 인덱스나 조건에 맞는 Enemy를 비활성화 처리.
4. 문제의 목표는 “포인터 배열 구조”를 활용해,
   동적 객체들을 배열처럼 관리하는 패턴을 연습하는 것이다.

---

## 문제 7. 스킬(Skill) 정보 관리 – 구조체 배열과 포인터

**핵심 개념:** 구조체, 구조체 배열, 포인터

### 시나리오

플레이어는 여러 개의 스킬을 가진다.
각 스킬은 이름, 마나 소모량, 쿨타임을 갖는다.

### 요구사항

1. `Skill` 구조체를 설계하라.

   * 예: `const char* name; int manaCost; float cooldown;`
2. 플레이어의 전체 스킬을 `Skill skillSet[MAX_SKILL];`
   형태의 **구조체 배열**로 관리한다고 가정한다.
3. 다음 기능이 있는 함수를 설계하라:

   * 특정 인덱스의 스킬 정보를 출력하는 함수 (포인터 인자 사용 가능).
   * 현재 보유 중인 모든 스킬 정보를 순회하며 출력하는 함수.
   * 특정 조건(마나 소모량, 쿨타임 등)에 맞는 스킬을 찾아
     그 **주소를 리턴**하는 함수 (없다면 nullptr).
4. 이 문제에서 포인터는:

   * 구조체 배열 원소를 가리키는 포인터
   * `nullptr` 체크
     등을 연습하는 데 집중한다.

---

## 문제 8. Player & Weapon 장착 시스템 – 클래스와 참조/포인터

**핵심 개념:** 클래스, 멤버 함수, 포인터/레퍼런스 인자

### 시나리오

Player는 한 개의 Weapon을 장착할 수 있다.
Weapon 교체 시, Player의 공격력이 변해야 한다.

### 요구사항

1. `Weapon` 클래스를 설계하라.

   * 예: `name`, `attackPower` 멤버, 간단한 생성자.
2. `Player` 클래스를 설계하라.

   * 예: `baseAttack`, `currentWeapon`, `GetTotalAttack()` 멤버 함수 등.
3. 다음과 같은 함수를 설계하라:

   * `EquipWeapon`:

     * Weapon 객체를 **레퍼런스나 포인터**로 받아 Player에 장착시키는 함수.
   * `UnEquipWeapon`:

     * 현재 장착된 무기를 해제하는 함수.
4. `main`에서:

   * 서로 다른 여러 무기를 만들고,
   * Player가 무기를 교체할 때마다 공격력이 어떻게 변하는지 출력하는 흐름을 구성하라.
5. 설계 단계에서 “이 함수는 포인터로 받을지, 레퍼런스로 받을지”를
   스스로 결정하고, 그 이유를 코드 주석이나 의사코드로 정리해라.

---

## 문제 9. 게임 오브젝트 변환 – 구조체에서 클래스 리팩터링

**핵심 개념:** 구조체, 클래스, 캡슐화, CallByReference

### 시나리오

기존 코드에서는 게임 오브젝트 정보를 단순 구조체로만 관리한다.
이를 캡슐화된 클래스로 바꾸는 리팩터링 작업을 한다.

### 요구사항

1. 기존 구조체 형태 (예시):

   ```cpp
   struct GameObject {
       float x;
       float y;
       float rotation;
       float scale;
   };
   ```

   와 비슷한 구조를 가정하고 시작한다.
2. 이 구조체를 다음과 같은 기능을 가진 클래스로 리팩터링하는 설계를 하라:

   * 위치/회전/스케일을 private 멤버로 숨기기.
   * 위치를 이동시키는 `Translate(dx, dy)` 멤버 함수.
   * 회전을 변경하는 `Rotate(dAngle)` 멤버 함수.
   * 현재 상태를 출력하는 `PrintStatus()` 멤버 함수.
3. 외부 헬퍼 함수 하나를 작성하라.

   * `GameObject`를 **레퍼런스**로 받아서,
     특정 규칙에 따라 위치/회전/스케일을 동시에 변경해 주는 함수.
4. 구조체에서 클래스로 바꾸면서,

   * **왜 캡슐화가 필요한지**,
   * 함수 인자에서 레퍼런스를 어떻게 사용하는지
     를 의사코드와 코드로 표현하는 것이 이 문제의 목적이다.

---

## 문제 10. 카메라 시점 전환 – 포인터 배열 + CallByPointer

**핵심 개념:** 포인터 배열, 클래스, CallByPointer

### 시나리오

3인칭 게임에서 여러 개의 카메라 뷰(예: 기본, 줌인, 탑뷰)를 준비해 두고,
플레이어 입력에 따라 활성 카메라를 전환한다.

### 요구사항

1. `Camera` 클래스를 설계하라.

   * `name`, `fov`, `isActive` 등을 멤버로 둘 수 있다.
   * `Activate()`, `Deactivate()`, `PrintStatus()` 같은 간단한 메서드 포함.
2. 카메라들을 `Camera* cameras[NUM_CAMERAS];`
   형태의 **포인터 배열**로 관리한다고 가정한다.
3. 다음 기능을 하는 함수를 설계하라:

   * 현재 활성 카메라를 찾아 비활성화하고,
   * 새로 활성화할 카메라의 주소를 받아 활성화 상태로 바꾸는 함수
     (인자를 포인터로 받아 CallByPointer 스타일로 처리).
4. `main`에서:

   * 여러 카메라를 생성하고 배열에 넣은 뒤,
   * “1번 뷰로 전환”, “2번 뷰로 전환” 같은 호출을 여러 번 수행해,
   * 어떤 카메라가 활성 상태인지 매번 출력해서 확인하는 흐름을 만들라.
